<?xml version="1.0" encoding="utf-8" ?>

<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head>

  <script type="text/javascript" language="JavaScript">
    //<![CDATA[
    function reDo() {
      if (innerWidth != origWidth || innerHeight != origHeight)
        location.reload();
    }
    if ((parseInt(navigator.appVersion) == 4) && (navigator.appName == "Netscape")) {
      origWidth = innerWidth;
      origHeight = innerHeight;
      onresize = reDo;
    }
    onerror = null;
  //]]>
  </script>
  <style type="text/css">/*<![CDATA[*/

    < !-- div.WebHelpPopupMenu {
      position: absolute;
      left: 0px;
      top: 0px;
      z-index: 4;
      visibility: hidden;
    }

    p.WebHelpNavBar {
      text-align: right;
    }

    -->
  
/*]]>*/</style>

  <script type="text/javascript">//<![CDATA[

    gRootRelPath = "../..";
    gCommonRootRelPath = "../..";
    gTopicId = "5.4.0_2";
  
//]]></script>

  <script type="text/javascript" src="../../template/scripts/rh.min.js"></script>
  <script type="text/javascript" src="../../template/scripts/common.min.js"></script>
  <script type="text/javascript" src="../../template/scripts/topic.min.js"></script>
  <script type="text/javascript" src="../../template/scripts/topicwidgets.min.js"></script>
<script type="text/javascript" src="../../whxdata/projectsettings.js"></script>
  <link rel="stylesheet" type="text/css" href="../../template/styles/topic.min.css"/>
  <link rel="stylesheet" type="text/css" href="../../template/Charcoal_Grey/topicheader.css"/>
  <meta name="topic-status" content="Draft"/>

  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <title>Room Properties</title>
  <meta name="generator" content="Adobe RoboHelp 2019"/>
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css"/>
  <meta name="rh-authors" content="Mark Alexander"/>
  <meta name="topic-comment" content="Page detailing the different room properties"/>
  <meta name="rh-index-keywords" content="Rooms - Room Settings"/>
  <meta name="search-keywords" content="room settings,cameras,viewports,room size,room properties,view cameras"/>
</head>

<body>
  <div class="topic-header rh-hide" id="rh-topic-header" onclick="rh._.goToFullLayout()">
    <div class="logo">
    </div>
    <div class="nav">
      <div class="title" title="Room Properties">
        <span>Room Properties</span>
      </div>
      <div class="gotohome" title="Click here to see this page in full context">
        <span>Click here to see this page in full context</span>
      </div>
    </div>
  </div>
  <div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div>



  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Room Properties</h1>
  <p><img alt="Room Editor Properties" class="center" src="../../assets/Images/Asset_Editors/Editor_Room_RoomSettings.png"/>The room properties section is where you can set the inheritance toggle for the settings, as well as name the room and whether it
    is <strong>persistent </strong>or not. Normally, when you leave a room and return to the same room later, that room is reset to its initial settings. This is usually fine for most games but it may not be what you want in, for example, an RPG or any
    non-linear game, where you want to come and go between rooms and have them be the way you left it the last time. Checking the box labelled <strong>Persistent </strong>will do exactly that. The room status will be remembered and when you return to
    it later, it will be exactly the same as you left it, with it only being reset to the start state when the game is restarted. Note that there is <em>one </em>exception to this - if you marked certain objects as being persistent, instances of this
    object will <em>not </em>stay in the room but move to the next room.</p>
  <p>After that you have the option to <strong>Clear Display Buffer</strong>. This option, when checked, fills the <a class="tooltip" title="The display buffer is the &#39;canvas&#39; where everything is finally drawn. Some events target this directly (like the Pre Draw event), while others will first draw to the application surface and then draw that to the display buffer.">display buffer</a> with a colour. If you know that the views are going to be
    covering the whole screen at all times or that you have a fullscreen background being drawn, then you can un-check this (which saves a redraw and so helps optimise your game), but if you have overlapping views that, when on the screen leave open spaces,
    or your background has any transparency, you should check this so that those area where there is no view are filled in with the draw colour of your choice. Currently this colour can only be set through code using <a href="../../GameMaker_Language/GML_Reference/Cameras_And_Display/The_Game_Window/window_set_colour.htm"><span class="inline">window_set_colour()</span></a>.</p>
  <p class="note"><strong>NOTE</strong>: If you are using automatic aspect ratio correction (as set in the <a href="../../Settings/Game_Options.htm">Game Options</a>), then you should <strong>always </strong>have this checked otherwise you can get odd effects over the
    &quot;letterbox&quot; that your game is drawn in. If you do not use this option then you can un-check this and get a small boost to your games performance (especially noticeable on Android and other mobile platforms).</p>
  <p>A room has to have a size and this is defined by the values that you input for its width and height in pixels, and once that has been set you can then go on to add <strong>Creation Code</strong>, should you require it. Creation code is added from the
    button at the bottom (along with the inherit toggle to say whether the room should inherit it&#39;s creation code or not), and if you click it you will open a code or DnD™ editor. This editor allows you to input functions/actions and code that will
    be run at the <em>start </em>of the room, after the create event of all instances but before their room start event (for more information on event order, please see <a href="../Object_Properties/Event_Order.htm">here</a>). This code will run every
    time you enter the room, unless the room is flagged as persistent, in which case it will only be run once when the room is first entered, but not on subsequent visits to the room.</p>
  <p>The final button in the Room Properties permits you to open the <strong>Instance Creation Order</strong> window:</p>
  <p><img alt="Instance Creation Order Window" class="center" src="../../assets/Images/Asset_Editors/Editor_Room_CreationOrder.png"/>This window lists all the instances in the room in the order that they will be created (from top to bottom). Should you
    require a specific instance to be created before any other, you can simply click <img alt="LMB Icon" class="icon" src="../../assets/Images/Icons/Icon_LMB.png"/> and drag it to the position your require. Note that instances will be created in the
    order given from top to bottom of the list.</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <h1>Cameras And Viewports</h1>
  <p>The next set of properties for the room that you can define are those relating to the room <strong>Camera</strong> and <strong>Viewports</strong>. Camera views give a mechanism for drawing different parts of your room at different places on the screen,
    or for drawing just a part of your room to cover the whole screen. For example, in most platform games, the camera view follows the main character, as, if you could see the whole level on the screen, your character would be too small to see and there
    would be no surprises for the player. Camera views can also be used in multi-player games or co-op games, as they permit you to create a split-screen setup in which in one part of the screen you see one player and in another part you see the other
    player. This can all be easily achieved in GameMaker Studio 2 using camera views.</p>
  <p><img alt="Camera And Viewport Properties" class="center" src="../../assets/Images/Asset_Editors/Editor_Room_RoomViews.png"/>At the top of the views properties you can toggle the view inheritance on or off, then there is a box labeled <strong>Enable Viewports</strong>.
    This <em>must be flagged</em> before any of the camera views can be active in your game.</p>
  <p class="note"><strong>NOTE</strong>: You can toggle inheritance on or off for the three main view port settings, and then you toggle inheritance on or off for each individual camera view.</p>
  <p>The next checkbox is the one that says <strong>Clear Viewport Background</strong>, which clears the <a class="tooltip" title="The application surface is a special built-in surface that GameMaker Studio 2 will draw everything to in the Draw Events of a game (a surface is essentially an area of memory reserved for graphics). This surface is then drawn to the display buffer at the end of each game frame, displaying its contents to the player.">application surface</a> with the window colour, and can be unchecked if you know that
    you are drawing to cover the whole surface.</p>
  <p>A camera view is defined by two different sets of values, the camera view itself and the port on the screen where this view is to be drawn. This can sometimes cause confusion so let&#39;s explain this a bit before explaining how we define each of them:</p>
  <ul class="colour">
    <li><strong>The Camera</strong>: A point within the room that will be used to set how the room is displayed on screen (this is an abstract piont in the room editor and its position is set automatically based on the view and view port settings)</li>
    <li><strong>The View</strong>: What the camera sees, based on the position, projection and rotation of the camera</li>
    <li><strong>The View Port</strong>: The area of the physical screen where the camera view will be displayed</li>
  </ul>
  <p><img alt="Camera View Example" class="center" src="../../assets/Images/Asset_Editors/Camera_Example.png"/>So, for example, this means that you can have a 640x480 camera view into your room, and then set the port to 320x240, which will display the view
    scaled down to that sized port on the screen, and you can also do the same and set the view to a smaller value and the port to larger making the image scale up to fit the port size and be shown on the screen larger than it is. In this way you can
    maintain a screen (port) size while changing the camera view to display more or less of the room in the same area of the screen.</p>
  <p>The camera view is always defined as a rectangular area in the room, where you specify the position of the top-left corner, the width and the height of this area. Then you must specify where this area is shown in the window on the screen by defining
    the view port, where again you specify the position of the top-left corner and the size (note that anything other than 0,0 for the top left corner can give strange results). You can have more than one port and they can overlap, in which case they
    are drawn in the indicated order one on top of the other.</p>
  <p>Please realise that the overall screen area is <em>always defined as a rectangular area</em>, so your ports, even when offset, will form a rectangle, with any empty spaces being filled in by the window colour of the <a class="tooltip" title="The display buffer is the &#39;canvas&#39; where everything is finally drawn. Some events target this directly (like the Pre Draw event), while others will first draw to the application surface and then draw that to the display buffer.">display buffer</a>, meaning that in these circumstances you should always have <strong>Clear Display Buffer</strong> checked or else you will get odd artefacts drawn in the spaces between ports. The image below illustrates this, where there
    are two offset view ports visible, yet they make a square window, and &quot;underneath&quot; there are lines being drawn to the display buffer:</p>
  <p><img alt="Object Editor Post Draw" class="center" src="../../assets/Images/Asset_Editors/Editor_Object_PostDraw.png"/>Cameras also have the <strong>Object Following </strong>option. This is for when you want the camera to &quot;follow&quot; (ie: maintain
    the view focused on) a certain object. To do this you must click <img alt="LMB Icon" class="icon" src="../../assets/Images/Icons/Icon_LMB.png"/> on the menu icon and select an object from the list that pops up (if there are multiple instances of
    this object in the room, only one of them is followed by the camera).</p>
  <p>The normal behaviour for a camera is to only move when the instance being followed gets too close to a &quot;buffer&quot; zone that makes an invisible boundary around the edge of the view. This zone can be defined by you using the <strong>Horizontal Border </strong>and
    <strong>Vertical Border </strong>values, so - for example - setting these values to 64 will mean that the view will not start to move and follow the character until it reaches 64 pixels from the edge of the view.</p>
  <p>Finally you can indicate the <strong>horizontal</strong> and <strong>vertical speed </strong>at which the camera moves when the character has reached the buffer zone, and this has a default value of -1. This default value is basically &quot;instantaneous&quot;
    and means that the moment the follow instance is outside the horizontal border or vertical border buffer zone, the view will skip to its current position. Now, this is not always what you want and so you can set the vertical and horizontal scrolling
    speed for the camera by setting the values to something other than -1. Note that a value of 0 will cause the view to not move at all, and any other positive value is how many pixels it will move in any frame, so setting the horizontal speed to 5 will
    have the view follow the object at 5 pixels per frame horizontally.</p>
  <p> </p>
  <p> </p>
  <h1>Room Physics</h1>
  <p>Before you can use the built in physics functions in your games, you must tell GameMaker Studio 2 that the room is a physics room. To do this, you must tick the option to <strong>Enable Physics </strong>at the top of the <em>Room Physics</em> section
    (you can also toggle the inheritance of this section independently of the rest of the room settings). Once you have done that you can then continue on to set up the physics world properties, which are some basic properties that you must have pre-defined
    before your room will allow physics instances to work as such. For a more precise control over the world you can use code (see the <a href="../../GameMaker_Language/GML_Reference/Physics/Physics.htm">Physics Functions</a> for more information).</p>
  <p><img alt="Room Physics Properties" class="center" src="../../assets/Images/Asset_Editors/Editor_Room_RoomPhysics.png"/>The next thing you must do is set up the <strong>Gravity </strong>of the world. The strength and direction of this is calculated
    as a <a class="tooltip" title="A vector is a mathematical construct that has a size, called the magnitude, and a direction. In GameMaker, a vector is usually used to show the distance and direction something moved in. A vector can also be used to define images and certain image formats like SWF use vector maths to define the images they contain.">vector</a> of the x/y position that you set around a (0, 0) point. So, an x of 0 and a y of 1 will set the gravity direction as being <em>down </em>with a force of 1 meter per second (for
    a more detailed explanation see - <a href="../../GameMaker_Language/GML_Reference/Physics/The_Physics_World/The_Physics_World.htm">The Physics World</a>).</p>
  <p>Finally you must set the ratio of<strong> Pixels To Meters</strong> for GameMaker Studio 2 to use as a base for all its physics calculations. This is because the physics functions work on real-world measurements, which is why we must set this value,
    and you&#39;ll want to adjust this setting until the average pixel size of the objects you are using translates roughly into simulated physics objects of an appropriate size.</p>
  <p>It should be noted that enabling physics in a room means that all instances in the room <em>must use the physics functios and variables to move</em>. Basically, you have &quot;traditional&quot; movement, where you can set the X/Y position of an instance
    or set its speed and direction, and then you have the &quot;physics&quot; movement, which requires physical forces and impulses to move around. These systems are <strong>mutually exlusive</strong>, and you cannot move a physics instance using non-physics
    functions and you cannot move a non-physics instance using the physics funtions.</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Back: <a href="../Rooms.htm">The Room Editor</a></div>
        <div style="float:right">Next: <a href="Room_Inheritance.htm">Room Inheritance</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2021 All Rights Reserved</span></h5>
  </div>
  <!-- KEYWORDS
Room Properties
View Ports
View Cameras
-->
  <!-- TAGS
rooms_properties
-->

</body></html>