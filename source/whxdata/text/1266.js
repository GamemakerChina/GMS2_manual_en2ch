rh._.exports({"0":["gpu_get_blendmode_ext_sepalpha"],"1":["gpu_get_blendmode_ext_sepalpha,bm_zero,bm_one,bm_src_colour,bm_inv_src_colour,bm_src_alpha,bm_inv_src_alpha,bm_dest_alpha,bm_inv_dest_alpha,bm_dest_colour,bm_inv_dest_colour,bm_src_alpha_sat,bm_src_color,bm_inv_src_color,bm_dest_color,bm_inv_dest_colour"],"2":["gpu_get_blendmode_ext_sepalpha,bm_zero,bm_one,bm_src_colour,bm_inv_src_colour,bm_src_alpha,bm_inv_src_alpha,bm_dest_alpha,bm_inv_dest_alpha,bm_dest_colour,bm_inv_dest_colour,bm_src_alpha_sat,bm_src_color,bm_inv_src_color,bm_dest_color,bm_inv_dest_colour"],"3":["\n  ","\n  ","\n  ","This function can be used to retrieve the current extended blend mode being used for drawing, separating out the blend modes into two parts - the RGB component and the Alpha component. The function returns a 4 element 1D array with the following elements\n    in it:","\n  ","\n    ","[0] = Source blend mode minus the alpha component (default is ","bm_src_alpha"," (As, As, As))","\n    ","[1] = Destination blend mode minus the alpha component (default is ","bm_inv_src_alpha"," (1-As, 1-As, 1-As))","\n    ","[2] = Source alpha component (default is ","bm_src_alpha"," (As))","\n    ","[3] = Destination alpha component (default is ","bm_inv_src_alpha"," (1-As))","\n  ","\n  ","The values of the array will be one of the following constants (\"s\" denotes a value taken from the source while a \"d\" denotes a value from the destination):","\n  "," ","\n  ","\n    ","\n      ","\n        ","Constant","\n        ","Blend factor (Red, Green, Blue, Alpha)","\n      ","\n      ","\n        ","bm_zero","\n        ","(0, 0, 0, 0)","\n      ","\n      ","\n        ","bm_one","\n        ","(1, 1, 1, 1)","\n      ","\n      ","\n        ","bm_src_colour","\n        ","(Rs, Gs, Bs, As)","\n      ","\n      ","\n        ","bm_inv_src_colour","\n        ","(1-Rs, 1-Gs, 1-Bs, 1-As)","\n      ","\n      ","\n        ","bm_src_alpha","\n        ","(As, As, As, As)","\n      ","\n      ","\n        ","bm_inv_src_alpha","\n        ","(1-As, 1-As, 1-As, 1-As)","\n      ","\n      ","\n        ","bm_dest_alpha","\n        ","(Ad, Ad, Ad, Ad)","\n      ","\n      ","\n        ","bm_inv_dest_alpha","\n        ","(1-Ad, 1-Ad, 1-Ad, 1-Ad)","\n      ","\n      ","\n        ","bm_dest_colour","\n        ","(Rd, Gd, Bd, Ad)","\n      ","\n      ","\n        ","bm_inv_dest_colour","\n        ","(1-Rd, 1-Gd, 1-Bd, 1-Ad)","\n      ","\n      ","\n        ","bm_src_alpha_sat","\n        ","(f, f, f, 1) where f = min(As, 1-Ad)","\n      ","\n    ","\n  ","\n  "," ","\n  ","When creating the extended blend modes in this way, the RGB components will be taken from one blend mode and the Alpha component will be taken from another, so that - for example - if you use ","bm_zero"," (0, 0, 0, 0) as the RGB blend mode and ","bm_one","    as the alpha blend mode, you will get a composite blend of (0,0,0,1).","\n  ","Note that you can change these values directly within the array and pass the full array to the function as a single argument (as shown in the example below).","\n  ","IMPORTANT!"," This function is currently only available on the ","Windows"," target platform.","\n  "," ","\n  ","\n  ","gpu_get_blendmode_ext_sepalpha();","\n  "," ","\n  ","\n  ","4 element 1D Array (see above for constants)","\n  "," ","\n  ","\n  ","var bm = gpu_get_blendmode_ext_sepalpha();"," bm[0] = bm_src_alpha;"," bm[1] = bm_inv_src_alpha;"," gpu_set_blendmode_ext_sepalpha(bm);\n  ","\n  ","The above code creates a local array and gets the current extended blend mode with separate alpha values. This array is then manipulated and returned to set the blend mode.","\n  "," ","\n  "," ","\n  "," ","\n  ","\n    ","\n      ","\n        ","Back: ","GPU Control","\n        ","Next: ","gpu_get_blendmode_src","\n      ","\n    ","\n    ","\n  ","\n  ","\n  ","\n\n"],"4":["gpu_get_blendmode_ext_sepalpha"],"5":["© Copyright YoYo Games Ltd. 2020 All Rights Reserved"],"7":["Syntax:","Returns:","Example:"],"id":"1266"})